#include "Node.h"
#include <iostream>
#include "NetworkInterface.h"
#include <iostream>
#include "Simulator.h"
#include "DropTailQueue.h"
#include "NetworkLink.h"


using namespace std;
//#include "Packet.cc"

#define INFINITY 10000000

using namespace std;

Node::Node(int addr)
{
	this->address = addr;
	sim = NULL;
}

int Node::getNodeCount()
{
//	return Node::NodeCount;
}

int Node::GetAddr()
{
	return address;
}

void Node::ComputeRoutes(vector<Node*> nodes)
{
	int* dist = new int(nodes.size());
	int* prev = new int(nodes.size());

	for(int i=0; i<nodes.size(); i++)
	{
		dist[i] = INFINITY;
		prev[i] = -1;
	}

	for(int i=0; i<neighbors.size(); i++)
	{
		dist[neighbors[i]->address] = 1;
		dist[neighbors[i]->address] = this->address;
	}

	while(!nodes.empty())
	{	
		int min = INFINITY;
		int index = -1;
		for(int i=0; i<nodes.size(); i++)
		{
			if(min < dist[i])
			{
				index = i;
				min = dist[i];
			}
			
		}

		for(int i=0; i<nodes[index]->neighbors.size(); i++)
		{
			if(dist[nodes[index]->neighbors[i]->address] > (min + 1))
			{
				dist[nodes[index]->neighbors[i]->address] = min + 1;
				prev[nodes[index]->neighbors[i]->address] = nodes[index]->address;
			}
		}

		/// Do the Swapping
		//int temp = dist[index];
		//dist[index];

	}
		
}

void Node::AddInterface(NetworkInterface* interface)
{
	if(interface != NULL)
		this->interfaces.push_back(interface);
	else
		cout << "ERROR!\nNull Interface" << endl;
}

void Node::AddNeighbor(Node* n)
{
	if(n != NULL)
	{
		//Node::NodeCount++;
		neighbors.push_back(n);
		nextHopRoutes.push_back(n->address);
		NetworkInterface *interface = new NetworkInterface();
		AddInterface(interface);
	}
	else
		cout << "ERROR!\nNULL node" << endl;	
}

void Node::AddApplication(Application* app)
{
	if(app != NULL)
	{
		applications.push_back(app);
	}
	else
		cout << "ERROR!\nNull Application" << endl;
	
}

void Node::Send(int count, int dest)
{
	Packet *p = new Packet(this->address, dest, count);
	/// Actually get the packet generated by the application the application
	// Packet *p = applications[0].generate()
	//// Look into routing table
	int index = 0;
	interfaces[index]->queue->Enque(p);
	double data_rate = interfaces[index]->link->dataRate;
	
	Time_t transmit_time = (double)(((DropTailQueue*)interfaces[index]->queue)->getLength())/data_rate;
	sim->Schedule(transmit_time, &NetworkInterface::Handle, interfaces[index]);
}

void Node::Receive(int count, int source)
{
	Packet *p = new Packet(source, this->address, count);
	// Send it to the ApplicationSync
}

void Node::Handle(int peer_addr, int size)
{
	cout << "Node handle called for " << address  << endl;
	this->Send(size, peer_addr);
}

/*void Node::Handle(Event* ev, Time_t t)
{
	if(ev->EventType == 0)
	{
		int size = neighbors.size();
		int dest = rand()%size;
		int count = rand()%100;

		this->Send(count, dest);
	}	
}*/
