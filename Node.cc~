#include "Node.h"
#include <iostream>
#include "NetworkInterface.h"
#include <iostream>
#include "Simulator.h"
#include "DropTailQueue.h"
#include "NetworkLink.h"
#include "Packet.cc"
#include "Application.h"

using namespace std;


#define INFINITY 10000000

using namespace std;

Node::Node(int addr)
{
	this->address = addr;
	sim = NULL;
}

int Node::getNodeCount()
{
//	return Node::NodeCount;
}

int Node::GetAddr()
{
	return address;
}

NetworkInterface* Node::GetInterface(int i)
{
	if(!interfaces.empty())
	return this->interfaces[i];
	else
	{
		cout << "Null Interface" << endl;
		return NULL;
	}
}

void Node::ComputeRoutes(vector<Node*> nodes)
{
	int* dist = new int(nodes.size());
	int* prev = new int(nodes.size());

	for(int i=0; i<nodes.size(); i++)
	{
		dist[i] = INFINITY;
		prev[i] = -1;
	}

	for(int i=0; i<neighbors.size(); i++)
	{
		dist[neighbors[i]->address] = 1;
		dist[neighbors[i]->address] = this->address;
	}

	while(!nodes.empty())
	{	
		int min = INFINITY;
		int index = -1;
		for(int i=0; i<nodes.size(); i++)
		{
			if(min < dist[i])
			{
				index = i;
				min = dist[i];
			}
			
		}

		for(int i=0; i<nodes[index]->neighbors.size(); i++)
		{
			if(dist[nodes[index]->neighbors[i]->address] > (min + 1))
			{
				dist[nodes[index]->neighbors[i]->address] = min + 1;
				prev[nodes[index]->neighbors[i]->address] = nodes[index]->address;
			}
		}

		/// Do the Swapping
		//int temp = dist[index];
		//dist[index];

	}
		
}

void Node::AddInterface(NetworkInterface* interface)
{
	if(interface != NULL)
		this->interfaces.push_back(interface);
	else
		cout << "ERROR!\nNull Interface" << endl;
}

void Node::AddNeighbor(int interface_a, Node* n, int interface_b)
{
	if(n != NULL)
	{
		//Node::NodeCount++;
		neighbors.push_back(n);
		nextHopRoutes.push_back(n->address);
	}
	else
		cout << "ERROR!\nNULL node" << endl;	
	CreateBiDirLinks(this->GetInterface(interface_a),n->GetInterface(interface_b));
}

void Node::AddApplication(Application* app)
{
	if(app != NULL)
	{
		applications.push_back(app);
	}
	else
		cout << "ERROR!\nNull Application" << endl;
	
}

void Node::Send(int count, int dest)
{
	Packet *p = new Packet(this->address, dest, count);
	/// Actually get the packet generated by the application the application
	// Packet *p = applications[0].generate()
	//// Look into routing table
	int index = 0;			//need to include routing table input
	interfaces[index]->queue->Enque(p);
	NetworkInterface* temp = interfaces[index];
	NetworkLink* temp_link = temp->link;
	double data_rate = temp_link->dataRate;
	Time_t transmit_time = (double)(((interfaces[index]->queue)->getLength())*PACKET_SIZE)/data_rate;
	sim->Schedule(transmit_time, &NetworkInterface::Handle, interfaces[index]);		//add transmit complete event to queue
}

void Node::Receive(int count, int source)
{
	Packet *p = new Packet(source, this->address, count);
	// Send it to the ApplicationSync
}

void Node::PacketGenerationComplete(int peer_addr, int size)
{
	cout << "Node handle called for " << address  << endl;
	this->Send(size, peer_addr);
}

/*void Node::Handle(Event* ev, Time_t t)
{
	if(ev->EventType == 0)
	{
		int size = neighbors.size();
		int dest = rand()%size;
		int count = rand()%100;

		this->Send(count, dest);
	}	
}*/

void CreateBiDirLinks(NetworkInterface* a, NetworkInterface* b)
{
	
	NetworkLink* link1 = new NetworkLink();		// a -> b
	a->link = link1;
        a->AddP2PLink(a->link, b);

	NetworkLink* link2 = new NetworkLink();		// b -> a
	b->link = link2;
        b->AddP2PLink(b->link, a);

}